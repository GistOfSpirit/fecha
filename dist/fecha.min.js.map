{"version":3,"file":"fecha.min.js","sources":["../src/fecha.ts"],"sourcesContent":["const token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nconst twoDigitsOptional = \"\\\\d\\\\d?\";\nconst twoDigits = \"\\\\d\\\\d\";\nconst threeDigits = \"\\\\d{3}\";\nconst fourDigits = \"\\\\d{4}\";\nconst word = \"[^\\\\s]+\";\nconst literal = /\\[([^]*?)\\]/gm;\nconst utcMarker = \"UTC:\";\n\ntype DateInfo = {\n  year: number;\n  month: number;\n  day: number;\n  hour: number;\n  minute: number;\n  second: number;\n  millisecond: number;\n  isPm: number | null;\n  timezoneOffset: number | null;\n};\n\nexport type I18nSettings = {\n  amPm: [string, string];\n  dayNames: Days;\n  dayNamesShort: Days;\n  monthNames: Months;\n  monthNamesShort: Months;\n  DoFn(dayOfMonth: number): string;\n};\n\nexport type I18nSettingsOptional = Partial<I18nSettings>;\n\nexport type Days = [string, string, string, string, string, string, string];\nexport type Months = [\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string\n];\n\nfunction shorten<T extends string[]>(arr: T, sLen: number): string[] {\n  const newArr: string[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    newArr.push(arr[i].substr(0, sLen));\n  }\n  return newArr;\n}\n\nconst monthUpdate = (\n  arrName: \"monthNames\" | \"monthNamesShort\" | \"dayNames\" | \"dayNamesShort\"\n) => (v: string, i18n: I18nSettings): number | null => {\n  const lowerCaseArr = i18n[arrName].map(v => v.toLowerCase());\n  const index = lowerCaseArr.indexOf(v.toLowerCase());\n  if (index > -1) {\n    return index;\n  }\n  return null;\n};\n\nexport function assign<A>(a: A): A;\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign(origObj: any, ...args: any[]): any {\n  for (const obj of args) {\n    for (const key in obj) {\n      // @ts-ignore ex\n      origObj[key] = obj[key];\n    }\n  }\n  return origObj;\n}\n\nconst dayNames: Days = [\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\"\n];\nconst monthNames: Months = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\"\n];\n\nconst monthNamesShort: Months = shorten(monthNames, 3) as Months;\nconst dayNamesShort: Days = shorten(dayNames, 3) as Days;\n\nconst defaultI18n: I18nSettings = {\n  dayNamesShort,\n  dayNames,\n  monthNamesShort,\n  monthNames,\n  amPm: [\"am\", \"pm\"],\n  DoFn(dayOfMonth: number) {\n    return (\n      dayOfMonth +\n      [\"th\", \"st\", \"nd\", \"rd\"][\n      dayOfMonth % 10 > 3\n        ? 0\n        : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10\n      ]\n    );\n  }\n};\nlet globalI18n = assign({}, defaultI18n);\nconst setGlobalDateI18n = (i18n: I18nSettingsOptional): I18nSettings =>\n  (globalI18n = assign(globalI18n, i18n));\n\nconst regexEscape = (str: string): string =>\n  str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n\nconst pad = (val: string | number, len = 2): string => {\n  val = String(val);\n  while (val.length < len) {\n    val = \"0\" + val;\n  }\n  return val;\n};\n\nconst getDate = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCDate() : dateObj.getDate();\nconst getDay = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCDay() : dateObj.getDay();\nconst getMonth = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCMonth() : dateObj.getMonth();\nconst getFullYear = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCFullYear() : dateObj.getFullYear();\nconst getHours = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCHours() : dateObj.getHours();\nconst getMinutes = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCMinutes() : dateObj.getMinutes();\nconst getSeconds = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCSeconds() : dateObj.getSeconds();\nconst getMilliseconds = (dateObj: Date, utc: boolean): number =>\n  utc ? dateObj.getUTCMilliseconds() : dateObj.getMilliseconds();\nconst getTimezoneOffset = (dateObj: Date, utc: boolean): number =>\n  utc ? 0 : dateObj.getTimezoneOffset();\n\nconst formatFlags: Record<\n  string,\n  (dateObj: Date, utc: boolean, i18n: I18nSettings) => string\n> = {\n  D: (dateObj: Date, utc: boolean): string => String(getDate(dateObj, utc)),\n  DD: (dateObj: Date, utc: boolean): string => pad(getDate(dateObj, utc)),\n  Do: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    i18n.DoFn(getDate(dateObj, utc)),\n  d: (dateObj: Date, utc: boolean): string => String(getDay(dateObj, utc)),\n  dd: (dateObj: Date, utc: boolean): string => pad(getDay(dateObj, utc)),\n  ddd: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    i18n.dayNamesShort[getDay(dateObj, utc)],\n  dddd: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    i18n.dayNames[getDay(dateObj, utc)],\n  M: (dateObj: Date, utc: boolean): string => String(getMonth(dateObj, utc) + 1),\n  MM: (dateObj: Date, utc: boolean): string => pad(getMonth(dateObj, utc) + 1),\n  MMM: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    i18n.monthNamesShort[getMonth(dateObj, utc)],\n  MMMM: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    i18n.monthNames[getMonth(dateObj, utc)],\n  YY: (dateObj: Date, utc: boolean): string =>\n    pad(String(getFullYear(dateObj, utc)), 4).substr(2),\n  YYYY: (dateObj: Date, utc: boolean): string => pad(getFullYear(dateObj, utc), 4),\n  h: (dateObj: Date, utc: boolean): string => String(getHours(dateObj, utc) % 12 || 12),\n  hh: (dateObj: Date, utc: boolean): string => pad(getHours(dateObj, utc) % 12 || 12),\n  H: (dateObj: Date, utc: boolean): string => String(getHours(dateObj, utc)),\n  HH: (dateObj: Date, utc: boolean): string => pad(getHours(dateObj, utc)),\n  m: (dateObj: Date, utc: boolean): string => String(getMinutes(dateObj, utc)),\n  mm: (dateObj: Date, utc: boolean): string => pad(getMinutes(dateObj, utc)),\n  s: (dateObj: Date, utc: boolean): string => String(getSeconds(dateObj, utc)),\n  ss: (dateObj: Date, utc: boolean): string => pad(getSeconds(dateObj, utc)),\n  S: (dateObj: Date, utc: boolean): string =>\n    String(Math.round(getMilliseconds(dateObj, utc) / 100)),\n  SS: (dateObj: Date, utc: boolean): string =>\n    pad(Math.round(getMilliseconds(dateObj, utc) / 10), 2),\n  SSS: (dateObj: Date, utc: boolean): string => pad(getMilliseconds(dateObj, utc), 3),\n  a: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    getHours(dateObj, utc) < 12 ? i18n.amPm[0] : i18n.amPm[1],\n  A: (dateObj: Date, utc: boolean, i18n: I18nSettings): string =>\n    getHours(dateObj, utc) < 12\n      ? i18n.amPm[0].toUpperCase()\n      : i18n.amPm[1].toUpperCase(),\n  ZZ(dateObj: Date, utc: boolean): string {\n    const offset = getTimezoneOffset(dateObj, utc);\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4)\n    );\n  },\n  Z(dateObj: Date, utc: boolean): string {\n    const offset = getTimezoneOffset(dateObj, utc);\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60), 2) +\n      \":\" +\n      pad(Math.abs(offset) % 60, 2)\n    );\n  }\n};\n\ntype ParseInfo = [\n  keyof DateInfo,\n  string,\n  ((v: string, i18n: I18nSettings) => number | null)?,\n  string?\n];\nconst monthParse = (v: string): number => +v - 1;\nconst emptyDigits: ParseInfo = [null, twoDigitsOptional];\nconst emptyWord: ParseInfo = [null, word];\nconst amPm: ParseInfo = [\n  \"isPm\",\n  word,\n  (v: string, i18n: I18nSettings): number | null => {\n    const val = v.toLowerCase();\n    if (val === i18n.amPm[0]) {\n      return 0;\n    } else if (val === i18n.amPm[1]) {\n      return 1;\n    }\n    return null;\n  }\n];\nconst timezoneOffset: ParseInfo = [\n  \"timezoneOffset\",\n  \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\",\n  (v: string): number | null => {\n    const parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n\n    if (parts) {\n      const minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n      return parts[0] === \"+\" ? minutes : -minutes;\n    }\n\n    return 0;\n  }\n];\nconst parseFlags: Record<string, ParseInfo> = {\n  D: [\"day\", twoDigitsOptional],\n  DD: [\"day\", twoDigits],\n  Do: [\"day\", twoDigitsOptional + word, (v: string): number => parseInt(v, 10)],\n  M: [\"month\", twoDigitsOptional, monthParse],\n  MM: [\"month\", twoDigits, monthParse],\n  YY: [\n    \"year\",\n    twoDigits,\n    (v: string): number => {\n      const now = new Date();\n      const cent = +(\"\" + now.getFullYear()).substr(0, 2);\n      return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n    }\n  ],\n  h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n  hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n  H: [\"hour\", twoDigitsOptional],\n  HH: [\"hour\", twoDigits],\n  m: [\"minute\", twoDigitsOptional],\n  mm: [\"minute\", twoDigits],\n  s: [\"second\", twoDigitsOptional],\n  ss: [\"second\", twoDigits],\n  YYYY: [\"year\", fourDigits],\n  S: [\"millisecond\", \"\\\\d\", (v: string): number => +v * 100],\n  SS: [\"millisecond\", twoDigits, (v: string): number => +v * 10],\n  SSS: [\"millisecond\", threeDigits],\n  d: emptyDigits,\n  dd: emptyDigits,\n  ddd: emptyWord,\n  dddd: emptyWord,\n  MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n  MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n  a: amPm,\n  A: amPm,\n  ZZ: timezoneOffset,\n  Z: timezoneOffset\n};\n\n// Some common format strings\nconst globalMasks: { [key: string]: string } = {\n  default: \"ddd MMM DD YYYY HH:mm:ss\",\n  shortDate: \"M/D/YY\",\n  mediumDate: \"MMM D, YYYY\",\n  longDate: \"MMMM D, YYYY\",\n  fullDate: \"dddd, MMMM D, YYYY\",\n  isoDate: \"YYYY-MM-DD\",\n  isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n  shortTime: \"HH:mm\",\n  mediumTime: \"HH:mm:ss\",\n  longTime: \"HH:mm:ss.SSS\"\n};\nconst setGlobalDateMasks = (masks: {\n  [key: string]: string;\n}): { [key: string]: string } => assign(globalMasks, masks);\n\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\nconst format = (\n  dateObj: Date,\n  mask: string = globalMasks[\"default\"],\n  i18n: I18nSettingsOptional = {}\n): string => {\n  if (typeof dateObj === \"number\") {\n    dateObj = new Date(dateObj);\n  }\n\n  if (\n    Object.prototype.toString.call(dateObj) !== \"[object Date]\" ||\n    isNaN(dateObj.getTime())\n  ) {\n    throw new Error(\"Invalid Date pass to format\");\n  }\n\n  const formatToUtc: boolean = mask.indexOf(utcMarker) === 0;\n\n  if (formatToUtc) {\n    mask = mask.substring(utcMarker.length);\n  }\n\n  mask = globalMasks[mask] || mask;\n\n  const literals: string[] = [];\n\n  // Make literals inactive by replacing them with @@@\n  mask = mask.replace(literal, function ($0, $1) {\n    literals.push($1);\n    return \"@@@\";\n  });\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n  // Apply formatting rules\n  mask = mask.replace(token, $0 =>\n    formatFlags[$0](dateObj, formatToUtc, combinedI18nSettings)\n  );\n  // Inline literal values back into the formatted value\n  return mask.replace(/@@@/g, () => literals.shift());\n};\n\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\nfunction parse(\n  dateStr: string,\n  format: string,\n  i18n: I18nSettingsOptional = {}\n): Date | null {\n  if (typeof format !== \"string\") {\n    throw new Error(\"Invalid format in fecha parse\");\n  }\n\n  // Check to see if the format is actually a mask\n  format = globalMasks[format] || format;\n\n  // Avoid regular expression denial of service, fail early for really long strings\n  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n  if (dateStr.length > 1000) {\n    return null;\n  }\n\n  // Default to the beginning of the year.\n  const today = new Date();\n  const dateInfo: DateInfo = {\n    year: today.getFullYear(),\n    month: 0,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    isPm: null,\n    timezoneOffset: null\n  };\n  const parseInfo: ParseInfo[] = [];\n  const literals: string[] = [];\n\n  // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n  let newFormat = format.replace(literal, ($0, $1) => {\n    literals.push(regexEscape($1));\n    return \"@@@\";\n  });\n  const specifiedFields: { [field: string]: boolean } = {};\n  const requiredFields: { [field: string]: boolean } = {};\n\n  // Change every token that we find into the correct regex\n  newFormat = regexEscape(newFormat).replace(token, $0 => {\n    const info = parseFlags[$0];\n    const [field, regex, , requiredField] = info;\n\n    // Check if the person has specified the same field twice. This will lead to confusing results.\n    if (specifiedFields[field]) {\n      throw new Error(`Invalid format. ${field} specified twice in format`);\n    }\n\n    specifiedFields[field] = true;\n\n    // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n    if (requiredField) {\n      requiredFields[requiredField] = true;\n    }\n\n    parseInfo.push(info);\n    return \"(\" + regex + \")\";\n  });\n\n  // Check all the required fields are present\n  Object.keys(requiredFields).forEach(field => {\n    if (!specifiedFields[field]) {\n      throw new Error(\n        `Invalid format. ${field} is required in specified format`\n      );\n    }\n  });\n\n  // Add back all the literals after\n  newFormat = newFormat.replace(/@@@/g, () => literals.shift());\n\n  // Check if the date string matches the format. If it doesn't return null\n  const matches = dateStr.match(new RegExp(newFormat, \"i\"));\n  if (!matches) {\n    return null;\n  }\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n\n  // For each match, call the parser function for that date part\n  for (let i = 1; i < matches.length; i++) {\n    const [field, , parser] = parseInfo[i - 1];\n    const value = parser\n      ? parser(matches[i], combinedI18nSettings)\n      : +matches[i];\n\n    // If the parser can't make sense of the value, return null\n    if (value == null) {\n      return null;\n    }\n\n    dateInfo[field] = value;\n  }\n\n  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n    dateInfo.hour = +dateInfo.hour + 12;\n  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n    dateInfo.hour = 0;\n  }\n\n  let dateTZ: Date;\n  if (dateInfo.timezoneOffset == null) {\n    dateTZ = new Date(\n      dateInfo.year,\n      dateInfo.month,\n      dateInfo.day,\n      dateInfo.hour,\n      dateInfo.minute,\n      dateInfo.second,\n      dateInfo.millisecond\n    );\n    const validateFields: [\n      \"month\" | \"day\" | \"hour\" | \"minute\" | \"second\",\n      \"getMonth\" | \"getDate\" | \"getHours\" | \"getMinutes\" | \"getSeconds\"\n    ][] = [\n        [\"month\", \"getMonth\"],\n        [\"day\", \"getDate\"],\n        [\"hour\", \"getHours\"],\n        [\"minute\", \"getMinutes\"],\n        [\"second\", \"getSeconds\"]\n      ];\n    for (let i = 0, len = validateFields.length; i < len; i++) {\n      // Check to make sure the date field is within the allowed range. Javascript dates allows values\n      // outside the allowed range. If the values don't match the value was invalid\n      if (\n        specifiedFields[validateFields[i][0]] &&\n        dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()\n      ) {\n        return null;\n      }\n    }\n  } else {\n    dateTZ = new Date(\n      Date.UTC(\n        dateInfo.year,\n        dateInfo.month,\n        dateInfo.day,\n        dateInfo.hour,\n        dateInfo.minute - dateInfo.timezoneOffset,\n        dateInfo.second,\n        dateInfo.millisecond\n      )\n    );\n\n    // We can't validate dates in another timezone unfortunately. Do a basic check instead\n    if (\n      dateInfo.month > 11 ||\n      dateInfo.month < 0 ||\n      dateInfo.day > 31 ||\n      dateInfo.day < 1 ||\n      dateInfo.hour > 23 ||\n      dateInfo.hour < 0 ||\n      dateInfo.minute > 59 ||\n      dateInfo.minute < 0 ||\n      dateInfo.second > 59 ||\n      dateInfo.second < 0\n    ) {\n      return null;\n    }\n  }\n\n  // Don't allow invalid dates\n\n  return dateTZ;\n}\nexport default {\n  format,\n  parse,\n  defaultI18n,\n  setGlobalDateI18n,\n  setGlobalDateMasks\n};\nexport { format, parse, defaultI18n, setGlobalDateI18n, setGlobalDateMasks };\n"],"names":["token","word","literal","shorten","arr","sLen","newArr","i","len","length","push","substr","monthUpdate","arrName","v","i18n","index","map","toLowerCase","indexOf","assign","origObj","_i","args","args_1","_a","obj","key","dayNames","monthNames","monthNamesShort","defaultI18n","dayNamesShort","amPm","DoFn","dayOfMonth","globalI18n","setGlobalDateI18n","regexEscape","str","replace","pad","val","String","getDate","dateObj","utc","getUTCDate","getDay","getUTCDay","getMonth","getUTCMonth","getFullYear","getUTCFullYear","getHours","getUTCHours","getMinutes","getUTCMinutes","getSeconds","getUTCSeconds","getMilliseconds","getUTCMilliseconds","getTimezoneOffset","formatFlags","D","DD","Do","d","dd","ddd","dddd","M","MM","MMM","MMMM","YY","YYYY","h","hh","H","HH","m","mm","s","ss","S","Math","round","SS","SSS","a","A","toUpperCase","ZZ","offset","floor","abs","Z","monthParse","emptyDigits","emptyWord","timezoneOffset","parts","match","minutes","parseInt","parseFlags","cent","Date","undefined","globalMasks","default","shortDate","mediumDate","longDate","fullDate","isoDate","isoDateTime","shortTime","mediumTime","longTime","setGlobalDateMasks","masks","format","mask","Object","prototype","toString","call","isNaN","getTime","Error","formatToUtc","substring","literals","$0","$1","combinedI18nSettings","shift","parse","dateStr","dateInfo","year","month","day","hour","minute","second","millisecond","isPm","parseInfo","newFormat","specifiedFields","requiredFields","info","field","regex","requiredField","keys","forEach","matches","RegExp","dateTZ","parser","value","validateFields","UTC"],"mappings":"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"}